<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script>
		function Op(ert,asd){
			//初始化
			this.ert=ert;
			this.asd=asd;
			this.skt=['java','script','html']
		}
        //Op的原型
        Op.prototype.xingzou="我天生就会行走";
        
        function Stu(lol){
        	//初始化
        	this.lol=lol;
        }
        //Stu原型指向Op
        Stu.prototype=new Op("我会吃饭","热")
          
          
        xiaoming= new Stu("放学回家");  
          console.log(xiaoming.asd)
         
         //利用数组添加
        xiaoming.skt.push("css")    
        console.log(xiaoming.skt)
  
        //小白也能够调用
         xiaobai=new Stu("王者")
         console.log(xiaobai.skt)
         console.log(xingzou)
         
         
      // 在xiaobai实例身上修改的 People.skill 后 Student.skill 也变了，
      // 因为来自原型对象的引用属性是所有实例共享的。
      // 可以这样理解：执行xiaoming.skill.push("golang");
      // 先对xiaoming进行属性查找,找遍了实例属性,没找到，就开始往原型身上查找，
      // 拿到了People.prototype 的 skill 发现有 skill属性，
      // 于是就给这个 skill 末尾插入了 golang 。
      // 此时此刻小白同学 的skill 通过查找原型对象，
      // 直到People.prototype 的skill 属性返回
	</script>
</html>
